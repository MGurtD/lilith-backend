using Application.Contracts;
using Domain.Entities.Production;
using Microsoft.Extensions.Logging;

namespace Application.Services.Production;

public class ProductionPartGeneratorHandler(
    IUnitOfWork unitOfWork,
    IProductionPartService productionPartService,
    ILogger<ProductionPartGeneratorHandler> logger) : IProductionPartGeneratorHandler
{
    public async Task GenerateFromPhaseClose(GenerateProductionPartsRequest request)
    {
        // 1. Obtenir la fase i els seus detalls
        var phase = await unitOfWork.WorkOrders.Phases.Get(request.WorkOrderPhaseId);
        if (phase == null)
        {
            logger.LogWarning("Fase {PhaseId} no trobada, no es generen tiquets", request.WorkOrderPhaseId);
            return;
        }

        // Ignorar fases de treball extern
        if (phase.IsExternalWork)
        {
            logger.LogInformation("Fase {PhaseId} es treball extern, no es generen tiquets", request.WorkOrderPhaseId);
            return;
        }

        var phaseDetails = unitOfWork.WorkOrders.Phases.Details
            .Find(d => d.WorkOrderPhaseId == request.WorkOrderPhaseId)
            .ToList();

        if (phaseDetails.Count == 0)
        {
            logger.LogWarning("Fase {PhaseId} no te detalls, no es generen tiquets", request.WorkOrderPhaseId);
            return;
        }

        // 2. Eliminar tiquets auto-generats anteriors per aquesta fase
        await RemoveExistingAutoGeneratedParts(request.WorkOrderPhaseId);

        // 3. Obtenir tots els WorkcenterShiftDetail tancats per aquesta fase (tots els centres de treball)
        var shiftDetails = unitOfWork.WorkcenterShifts.Details
            .Find(d => d.WorkOrderPhaseId == request.WorkOrderPhaseId
                     && d.EndTime != null
                     && !d.Disabled)
            .ToList();

        if (shiftDetails.Count == 0)
        {
            logger.LogInformation("Fase {PhaseId} no te detalls de torn, no es generen tiquets", request.WorkOrderPhaseId);
            return;
        }

        // 4. Agrupar per (MachineStatusId, OperatorId) - NomÃ©s detalls amb operari
        var groups = shiftDetails
            .Where(d => d.OperatorId.HasValue)
            .GroupBy(d => new { d.MachineStatusId, OperatorId = d.OperatorId!.Value });

        var generatedCount = 0;
        foreach (var group in groups)
        {
            // 5. Trobar el WorkOrderPhaseDetail corresponent per MachineStatusId
            var phaseDetail = phaseDetails
                .FirstOrDefault(pd => pd.MachineStatusId == group.Key.MachineStatusId);

            if (phaseDetail == null)
            {
                logger.LogDebug(
                    "No s'ha trobat detall de fase per MachineStatusId {StatusId} a la fase {PhaseId}, s'omet",
                    group.Key.MachineStatusId, request.WorkOrderPhaseId);
                continue;
            }

            // 6. Agregar temps i quantitats
            decimal workcenterTime = 0;
            decimal operatorTime = 0;
            decimal quantity = 0;
            decimal weightedOperatorCostSum = 0;
            decimal weightedWorkcenterCostSum = 0;
            decimal totalDuration = 0;

            foreach (var detail in group)
            {
                var duration = (decimal)(detail.EndTime!.Value - detail.StartTime).TotalMinutes;
                if (duration <= 0) continue;

                workcenterTime += duration;

                var concurrentOperators = detail.ConcurrentOperatorWorkcenters > 0
                    ? detail.ConcurrentOperatorWorkcenters : 1;
                operatorTime += duration / concurrentOperators;

                quantity += detail.QuantityOk;

                // Cost ponderat pel temps
                weightedOperatorCostSum += detail.OperatorCost * duration;
                weightedWorkcenterCostSum += detail.WorkcenterCost * duration;
                totalDuration += duration;
            }

            if (totalDuration <= 0) continue;

            // Cost horari ponderat per temps
            var weightedOperatorHourCost = weightedOperatorCostSum / totalDuration;
            var weightedMachineHourCost = weightedWorkcenterCostSum / totalDuration;

            // Determinar el WorkcenterId a partir dels detalls del grup
            var workcenterId = await GetWorkcenterIdFromShiftDetail(group.First());

            // 7. Crear el ProductionPart
            var productionPart = new ProductionPart
            {
                Id = Guid.NewGuid(),
                Date = request.ClosedAt,
                WorkcenterId = workcenterId,
                WorkOrderId = phase.WorkOrderId,
                WorkOrderPhaseId = request.WorkOrderPhaseId,
                WorkOrderPhaseDetailId = phaseDetail.Id,
                OperatorId = group.Key.OperatorId,
                Quantity = (int)quantity,
                OperatorTime = Math.Round(operatorTime, 2),
                WorkcenterTime = Math.Round(workcenterTime, 2),
                OperatorHourCost = Math.Round(weightedOperatorHourCost, 4),
                MachineHourCost = Math.Round(weightedMachineHourCost, 4),
                IsAutoGenerated = true
            };

            await productionPartService.CreateWithoutCostLookup(productionPart);
            generatedCount++;
        }

        logger.LogInformation(
            "Generats {Count} tiquets de produccio per la fase {PhaseId}",
            generatedCount, request.WorkOrderPhaseId);
    }

    private async Task RemoveExistingAutoGeneratedParts(Guid workOrderPhaseId)
    {
        var existingParts = unitOfWork.ProductionParts
            .Find(pp => pp.WorkOrderPhaseId == workOrderPhaseId && pp.IsAutoGenerated)
            .ToList();

        foreach (var part in existingParts)
        {
            await productionPartService.Remove(part.Id);
        }

        if (existingParts.Count > 0)
        {
            logger.LogInformation(
                "Eliminats {Count} tiquets auto-generats anteriors per la fase {PhaseId}",
                existingParts.Count, workOrderPhaseId);
        }
    }

    private async Task<Guid> GetWorkcenterIdFromShiftDetail(WorkcenterShiftDetail shiftDetail)
    {
        var workcenterShift = await unitOfWork.WorkcenterShifts.Get(shiftDetail.WorkcenterShiftId);
        return workcenterShift?.WorkcenterId ?? Guid.Empty;
    }
}
