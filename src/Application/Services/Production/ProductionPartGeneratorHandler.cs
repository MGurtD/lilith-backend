using Application.Contracts;
using Domain.Entities.Production;
using Microsoft.Extensions.Logging;

namespace Application.Services.Production;

public class ProductionPartGeneratorHandler(
    IUnitOfWork unitOfWork,
    ILogger<ProductionPartGeneratorHandler> logger) : IProductionPartGeneratorHandler
{
    public async Task GenerateFromPhaseClose(GenerateProductionPartsRequest request)
    {
        // 1. Obtenir la fase i els seus detalls
        var phase = await unitOfWork.WorkOrders.Phases.Get(request.WorkOrderPhaseId);
        if (phase == null)
        {
            logger.LogWarning("Fase {PhaseId} no trobada, no es generen tiquets", request.WorkOrderPhaseId);
            return;
        }

        // Ignorar fases de treball extern
        if (phase.IsExternalWork)
        {
            logger.LogInformation("Fase {PhaseId} es treball extern, no es generen tiquets", request.WorkOrderPhaseId);
            return;
        }

        var phaseDetails = unitOfWork.WorkOrders.Phases.Details
            .Find(d => d.WorkOrderPhaseId == request.WorkOrderPhaseId)
            .ToList();

        if (phaseDetails.Count == 0)
        {
            logger.LogWarning("Fase {PhaseId} no te detalls, no es generen tiquets", request.WorkOrderPhaseId);
            return;
        }

        // 2. Eliminar tiquets auto-generats anteriors i obtenir els seus totals
        var removedTotals = await RemoveExistingAutoGeneratedParts(request.WorkOrderPhaseId);

        // 3. Obtenir tots els WorkcenterShiftDetail tancats per aquesta fase (tots els centres de treball)
        var shiftDetails = unitOfWork.WorkcenterShifts.Details
            .Find(d => d.WorkOrderPhaseId == request.WorkOrderPhaseId
                     && d.EndTime != null
                     && !d.Disabled)
            .ToList();

        if (shiftDetails.Count == 0)
        {
            // Still need to update WorkOrder if we removed parts
            if (removedTotals != null)
                await ApplyWorkOrderTotals(phase.WorkOrderId, null, removedTotals);

            logger.LogInformation("Fase {PhaseId} no te detalls de torn, no es generen tiquets", request.WorkOrderPhaseId);
            return;
        }

        // 4. Agrupar per (WorkcenterShiftId, MachineStatusId, OperatorId) - Només detalls amb operari
        var groups = shiftDetails
            .Where(d => d.OperatorId.HasValue)
            .GroupBy(d => new { d.WorkcenterShiftId, d.MachineStatusId, OperatorId = d.OperatorId!.Value });

        // Build all ProductionParts first, then persist in batch
        var partsToCreate = new List<ProductionPart>();
        foreach (var group in groups)
        {
            // 5. Trobar el WorkOrderPhaseDetail corresponent per MachineStatusId
            var phaseDetail = phaseDetails
                .FirstOrDefault(pd => pd.MachineStatusId == group.Key.MachineStatusId);

            if (phaseDetail == null)
            {
                logger.LogDebug(
                    "No s'ha trobat detall de fase per MachineStatusId {StatusId} a la fase {PhaseId}, s'omet",
                    group.Key.MachineStatusId, request.WorkOrderPhaseId);
                continue;
            }

            // 6. Agregar temps i quantitats
            decimal workcenterTime = 0;
            decimal operatorTime = 0;
            decimal quantity = 0;
            decimal weightedOperatorCostSum = 0;
            decimal weightedWorkcenterCostSum = 0;
            decimal totalDuration = 0;
            DateTime? minStartTime = null;

            foreach (var detail in group)
            {
                var duration = (decimal)(detail.EndTime!.Value - detail.StartTime).TotalMinutes;
                if (duration <= 0) continue;

                workcenterTime += duration;

                var concurrentOperators = detail.ConcurrentOperatorWorkcenters > 0
                    ? detail.ConcurrentOperatorWorkcenters : 1;
                operatorTime += duration / concurrentOperators;

                quantity += detail.QuantityOk;

                // Cost ponderat pel temps
                weightedOperatorCostSum += detail.OperatorCost * duration;
                weightedWorkcenterCostSum += detail.WorkcenterCost * duration;
                totalDuration += duration;

                // Track minimum StartTime for Date field
                if (minStartTime == null || detail.StartTime < minStartTime)
                    minStartTime = detail.StartTime;
            }

            if (totalDuration <= 0) continue;

            // Cost horari ponderat per temps
            var weightedOperatorHourCost = weightedOperatorCostSum / totalDuration;
            var weightedMachineHourCost = weightedWorkcenterCostSum / totalDuration;

            // Determinar el WorkcenterId a partir dels detalls del grup
            var workcenterId = await GetWorkcenterIdFromShiftDetail(group.First());

            // 7. Crear el ProductionPart
            partsToCreate.Add(new ProductionPart
            {
                Id = Guid.NewGuid(),
                Date = minStartTime ?? request.ClosedAt, // Use earliest work start date, fallback to close timestamp
                WorkcenterId = workcenterId,
                WorkOrderId = phase.WorkOrderId,
                WorkOrderPhaseId = request.WorkOrderPhaseId,
                WorkOrderPhaseDetailId = phaseDetail.Id,
                OperatorId = group.Key.OperatorId,
                Quantity = (int)quantity,
                OperatorTime = Math.Round(operatorTime, 2),
                WorkcenterTime = Math.Round(workcenterTime, 2),
                OperatorHourCost = Math.Round(weightedOperatorHourCost, 4),
                MachineHourCost = Math.Round(weightedMachineHourCost, 4),
                IsAutoGenerated = true
            });
        }

        if (partsToCreate.Count == 0)
        {
            // Still need to update WorkOrder if we removed parts
            if (removedTotals != null)
                await ApplyWorkOrderTotals(phase.WorkOrderId, null, removedTotals);

            logger.LogInformation("Fase {PhaseId} no te grups amb operari, no es generen tiquets", request.WorkOrderPhaseId);
            return;
        }

        // 8. Persist all parts
        await unitOfWork.ProductionParts.AddRange(partsToCreate);

        // 9. Single WorkOrder update: subtract removed totals + add new totals
        await ApplyWorkOrderTotals(phase.WorkOrderId, partsToCreate, removedTotals);

        logger.LogInformation(
            "Generats {Count} tiquets de produccio per la fase {PhaseId}",
            partsToCreate.Count, request.WorkOrderPhaseId);
    }

    /// <summary>
    /// Removes existing auto-generated parts from the database and returns their
    /// aggregated totals (to be subtracted from WorkOrder later).
    /// Does NOT touch the WorkOrder — caller is responsible for that.
    /// </summary>
    private async Task<PartTotals?> RemoveExistingAutoGeneratedParts(Guid workOrderPhaseId)
    {
        var existingParts = unitOfWork.ProductionParts
            .Find(pp => pp.WorkOrderPhaseId == workOrderPhaseId && pp.IsAutoGenerated)
            .ToList();

        if (existingParts.Count == 0) return null;

        // Aggregate totals in memory (untracked data)
        var totals = new PartTotals();
        foreach (var part in existingParts)
        {
            totals.OperatorTime += part.OperatorTime;
            totals.MachineTime += part.WorkcenterTime;
            totals.TotalQuantity += part.Quantity;
            totals.MachineCost += (part.WorkcenterTime / 60) * part.MachineHourCost;
            totals.OperatorCost += (part.OperatorTime / 60) * part.OperatorHourCost;
        }

        // Clear navigation properties before RemoveRange to avoid EF tracking conflicts.
        // ProductionPartRepository.Find() eagerly loads WorkOrder, WorkOrderPhase, etc.
        // If multiple parts reference the same WorkOrder, RemoveRange's graph attachment
        // would try to track duplicate WorkOrder instances, causing IdentityConflict.
        foreach (var part in existingParts)
        {
            part.WorkOrder = null;
            part.WorkOrderPhase = null;
            part.WorkOrderPhaseDetail = null;
            part.Workcenter = null;
            part.Operator = null;
        }

        // Remove all auto-generated parts in one batch
        await unitOfWork.ProductionParts.RemoveRange(existingParts);

        logger.LogInformation(
            "Eliminats {Count} tiquets auto-generats anteriors per la fase {PhaseId}",
            existingParts.Count, workOrderPhaseId);

        return totals;
    }

    /// <summary>
    /// Single WorkOrder fetch + update that subtracts removed totals and adds new part totals.
    /// By doing a single Get/Update cycle, we avoid EF tracking conflicts.
    /// </summary>
    private async Task ApplyWorkOrderTotals(Guid workOrderId, List<ProductionPart>? addedParts, PartTotals? removedTotals)
    {
        var workOrder = await unitOfWork.WorkOrders.Get(workOrderId);
        if (workOrder == null) return;

        // Subtract removed part totals
        if (removedTotals != null)
        {
            workOrder.OperatorTime -= removedTotals.OperatorTime;
            workOrder.MachineTime -= removedTotals.MachineTime;
            workOrder.TotalQuantity -= removedTotals.TotalQuantity;
            workOrder.MachineCost -= removedTotals.MachineCost;
            workOrder.OperatorCost -= removedTotals.OperatorCost;
        }

        // Add new part totals
        if (addedParts != null)
        {
            foreach (var part in addedParts)
            {
                workOrder.OperatorTime += part.OperatorTime;
                workOrder.MachineTime += part.WorkcenterTime;
                workOrder.TotalQuantity += part.Quantity;
                workOrder.MachineCost += (part.WorkcenterTime / 60) * part.MachineHourCost;
                workOrder.OperatorCost += (part.OperatorTime / 60) * part.OperatorHourCost;
            }
        }

        await unitOfWork.WorkOrders.Update(workOrder);
    }

    private async Task<Guid> GetWorkcenterIdFromShiftDetail(WorkcenterShiftDetail shiftDetail)
    {
        var workcenterShift = await unitOfWork.WorkcenterShifts.Get(shiftDetail.WorkcenterShiftId);
        return workcenterShift?.WorkcenterId ?? Guid.Empty;
    }

    /// <summary>
    /// Simple POCO to carry aggregated totals without involving EF tracking.
    /// </summary>
    private class PartTotals
    {
        public decimal OperatorTime { get; set; }
        public decimal MachineTime { get; set; }
        public int TotalQuantity { get; set; }
        public decimal MachineCost { get; set; }
        public decimal OperatorCost { get; set; }
    }
}
